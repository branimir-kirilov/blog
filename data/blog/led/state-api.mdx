---
title: DIY desk RGB lights [Part 4] - State management and API calls
date: '2023-04-22'
tags: ['iot', 'LED', 'c', 'js', 'smarthome', 'reactnative', 'react', 'prompt', 'expo']
draft: true
summary: Using Redux as a state manager and dispatching API calls.
---

# Modifying the Wemos Server

The initial chapter involved setting up a server on the Wemos board that listens for ```GET``` calls specifically on ```/desk/rgb```. However, for the sake of consistency in the event of multiple light sources on multiple devices, I intend to modify this to a ```POST``` request on ```light/desk```, with the parameters being passed in the request body.

```c
// changing the mapping
server.on("/lights/desk", HTTP_POST, handleLightUpdate);
```

```c
// the updated POST handler that reads the JSON body
void handleLightUpdate()
{
    // Check if body received
    if (server.hasArg("plain") == false)
    {
        sendBadRequestResponse();
        return;
    }

    StaticJsonDocument<200> jsonDoc;
    deserializeJson(jsonDoc, server.arg("plain"));

    int r = jsonDoc["r"].as<int>();
    int g = jsonDoc["g"].as<int>();
    int b = jsonDoc["b"].as<int>();
    float brightness = jsonDoc["brightness"].as<float>();

    writeColor(r, g, b, brightness);
}
```

I have also extracted the code that sets the pin values to a different method - ```writeColor``` you can check the [full device code](https://github.com/branimir-kirilov/desk-lights/blob/main/device/device.ino) for its implementation.



# State management


Maintaining a tidy and organized codebase is essential when developing applications, especially those that are intended to be expanded over time. As I continue to build out my home automation project, I knew that effective state management would be a key factor in keeping the project maintainable in the long term.

After some research, I decided to utilize Redux Toolkit to handle state management. The toolkit provides a set of tools and guidelines that make it easier to write Redux code while also improving performance and reducing boilerplate.

To get started, I followed the Redux Toolkit's [quick start guide](https://redux-toolkit.js.org/tutorials/quick-start) which provided me with all the necessary information and packages required to use Redux Toolkit. Once all the necessary packages were installed, I created a ```/store``` folder to initialize my state, and I defined the rootReducer in ```rootReducer.ts```, which combines all the reducers used in the application. This centralizes the application's state and makes it more accessible to all components.

```typescript
// store.ts
import {
    configureStore,
    ThunkAction,
    Action,
} from '@reduxjs/toolkit';
import { rootReducer } from './rootReducer';

export const store = configureStore({
    reducer: rootReducer,
});

export type AppDispatch = typeof store.dispatch;
export type RootState = ReturnType<typeof store.getState>;
export type AppThunk<ReturnType = void> = ThunkAction<
    ReturnType,
    RootState,
    unknown,
    Action<string>
>;
```

```js
// rootReducer.ts
import { combineReducers } from '@reduxjs/toolkit';
import lightsSlice from './lights/lightsSlice';

export const rootReducer = combineReducers({
    lights: lightsSlice
});
```

From there, I defined the ```lightsSlice``` - the part of the store that manages the state of the lights in my application. To keep things organized, I placed all relevant files in ```store/lights```. As my light state management essentially consisted of simple CRUD operations, I made use of the [createEntityAdapter](https://redux-toolkit.js.org/api/createEntityAdapter) provided by Redux Toolkit. This generated a set of pre-built reducers and selectors for performing CRUD operations on a normalized state structure containing instances of a particular type of data object. In my case - ```EntityState<LightSouce>```.

The lightsSlice also includes an ```extraReducers``` field to handle the [async thunk](https://redux-toolkit.js.org/api/createAsyncThunk) that will load the lights list (I'll write it later). Additionally, I defined the lightUpdated action which uses the lightsAdapter's ```updateOne``` to update an individual light.

Finally, the code exports the lightUpdated ```action creator```, which can be used to update a single light entity within the store. The lightSelectors constant uses the ```getSelectors``` function from createEntityAdapter to generate a set of selectors for querying the lights slice of the store. These selectors can be used to access the ids and entities fields of the lights state, as well as any additional state fields added to the LightsState interface. By using these selectors, components can easily retrieve and display relevant portions of the store's state.

```js
// lightsSlice.ts
import { createEntityAdapter, createSlice, EntityState } from '@reduxjs/toolkit';
import { RootState } from '../store';
import { LightSource, Status } from '../../types/types';
import { fetchLightsData } from './lightsThunks';

interface LightsState extends EntityState<LightSource> {
    status: Status;
    error: string | null;
}

const lightsAdapter = createEntityAdapter<LightSource>({
    selectId: (lightSource) => lightSource.id,
    // temporarily sort desc by notImplemented field
    sortComparer: (a, b) => Number(b.notImplemented) - Number(a.notImplemented)
});

export const lightsSlice = createSlice({
    name: 'lightsSlice',
    initialState: lightsAdapter.getInitialState<LightsState>({
        ids: [],
        entities: {},
        status: Status.IDLE,
        error: null,
    }),
    reducers: {
        lightUpdated: lightsAdapter.updateOne,
    },
    extraReducers: (builder) => {
        builder
            .addCase(fetchLightsData.pending, (state) => {
                state.status = Status.LOADING;
            })
            .addCase(fetchLightsData.fulfilled, (state, action) => {
                state.status = Status.IDLE;
                lightsAdapter.upsertMany(state, action.payload);
            })
            .addCase(fetchLightsData.rejected, (state) => {
                state.status = Status.FAILED;
            })
    },
});

export const { lightUpdated } = lightsSlice.actions;

export const lightSelectors = lightsAdapter.getSelectors<RootState>(
    (state) => state.lights
)

export default lightsSlice.reducer;
```

In addition to the slice code I previously discussed, I'll also be implementing a service layer to handle API calls and defining hooks to access the state from React components. For now it's only a dummy function, because I don't have an actual API to fetch this data from, so I'll just resolve the promise with the data I defined earlier in the static JSON file:

```typescript
// LightService.ts
...
import Constants from 'expo-constants';

export default class LightService {
    // A mock function to mimic making an async GET request for light sources data
    static fetchLightsData() {
        return new Promise<{ data: LightSource[] }>((resolve) =>
            setTimeout(() => resolve({ data: lightsListData }), 0)
        );
    }
}
```

I'll also have to define the hooks that I'll use to access the state from my React components:

```typescript
// hooks.ts
import { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux';
import type { RootState, AppDispatch } from '../store/store';

export const useAppDispatch = () => useDispatch<AppDispatch>();
export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;
```

With the service layer defined, I can now create the async thunk that makes an "API call" using LightService and returns the response:

```js
// lightsThunks.ts
export const fetchLightsData = createAsyncThunk(
    'lights/fetchLightsData',
    async () => {
        const response = await LightService.fetchLightsData();
        return response.data;
    }
);
```

Now I can test my store by changing my ```<LightsList.tsx />``` component  to dispatch a fetchLightsData() action instead of importing the light data from the static file:

```typescript
// LightsList.tsx
import { useEffect } from 'react';
import { useAppDispatch, useAppSelector } from '../../hooks/hooks';
import { fetchLightsData } from '../../store/lights/lightsThunks';
import { lightSelectors } from '../../store/lights/lightsSlice';

export default function LightsList({ navigation }: LightsListProps) {
    const lights = useAppSelector(lightSelectors.selectAll); // selects all lights
    const dispatch = useAppDispatch();

    useEffect(() => {
        // dispatch an action to "fetch" the lights them when the component mounts
        dispatch(fetchLightsData());
    }, []);

    return (
        <>
            <FlatList
                data={lights} // use the lights
               ....
}
```

TODO: Check names of components and fix props - items etc


#### EAS

I'll also be using EAS to generate an APK (I use Android) that I can install on my own phone after I'm done with the app... or at least with the first iteration of it. Though, I 

> Expo EAS (Expo Application Services) is a suite of cloud-based tools and services offered by Expo to streamline the development, building, and publishing of React Native apps. It encompasses various features, such as faster builds, automated app signing, and publishing, advanced debugging, and crash reporting tools, among others. Expo EAS aims to simplify the React Native app development process and reduce the time and effort required to build, test, and deploy high-quality mobile applications.

[EAS setup](https://docs.expo.dev/build/setup/) - I'll cover this step by step later in this post






Apparently, the app has to make HTTP requests to the server that's running on the board. Usually, this would need some sort of authentication and authorization, but in my case I'm building this app only for myself. The server is running in my local network and I don't have any port forwarding. This means that only people connected to my network can interact with the server, provided that they know on which ip address and port it runs ( security through obscurity? :) ). At the end of the day, even if someone knows where the server is running, the most harm he can do is change the color of the lights on my desk or enable them when they shouldn't be. This would be annoying and would ultimately increase my electricity bills, but I'm willing to take the risk. ```If the application you're bulding is dealing with any kind of sensitive data, I don't recommend the solution from this blog post. Security is important, and we should always think about it especially when dealing with IoT.```
